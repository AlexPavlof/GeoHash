{"version":3,"sources":["webpack://geohash/webpack/bootstrap","webpack://geohash/./src/geohash.js"],"names":["BASE32_CODES","BASE32_CODES_DICT","ENCODE_AUTO","i","length","charAt","SIGFIG_HASH_LENGTH","DEFAULT_BIT_DEPTH","getBit","bits","position","getKeyLength","zoom","key","encode","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","decSigFigsLong","numberOfSigFigs","Math","max","undefined","parseFloat","parseInt","chars","bitsTotal","hashValue","maxLat","minLat","maxLon","minLon","mid","code","push","join","encodeInt","bitDepth","combinedBits","decodeBbox","hashString","isLon","l","toLowerCase","bit","decodeBboxInt","hashInt","latBit","lonBit","step","decode","bbox","lat","lon","latErr","lonErr","error","decodeInt","neighbor","direction","lonLat","neighborLat","neighborLon","neighborInt","lonlat","neighbors","hashstringLength","encodeNeighbor","neighborLatDir","neighborLonDir","neighborsInt","encodeNeighborInt","bboxes","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","bboxesInt","latlon"],"mappings":"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","file":"geohash.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/geohash.js\");\n","/* eslint-disable no-bitwise */\n// @flow\n/**\n * The Geohash algorithm was first described by Gustavo Niemeyer in February 2008. By interleaving\n * latitude and longitude information in a bitwise fashion, a composite value is generated that\n * provides a high resolution geographic point, and is well suited for storage or transmission as a\n * character string.\n *\n * Geohash also has the property that as the number of digits decreases (from the right), accuracy\n * degrades. This property can be used to do bounding box searches, as points near to one another\n * will share similar Geohash prefixes.\n *\n */\nexport const BASE32_CODES      = '0123456789bcdefghjkmnpqrstuvwxyz';\nexport const BASE32_CODES_DICT = {};\nexport const ENCODE_AUTO       = 'auto';\n\nfor (let i = 0; i < BASE32_CODES.length; i += 1) {\n    BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\n/**\n * Significant Figure Hash Length.\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n *\n * @type {*[]}\n */\nexport const SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n\n/**\n * Default bit depth.\n *\n * @type {number}\n */\nconst DEFAULT_BIT_DEPTH = 52;\n\n/**\n * Returns bit.\n *\n * @param {number} bits\n * @param {number} position\n * @return {number}\n */\nexport const getBit = (bits: number, position: number): number => (bits / (2 ** position)) & 0x01;\n\n/**\n * Returns an appropriate key length for a certain zoom.\n *\n * @param {number} zoom\n * @return {number}\n */\nexport const getKeyLength = (zoom: number): number => {\n    let key;\n\n    if (zoom >= 17) key = 8;\n    else if (zoom >= 15 && zoom < 17) key = 7;\n    else if (zoom >= 13 && zoom < 15) key = 6;\n    else if (zoom >= 11 && zoom < 13) key = 5;\n    else if (zoom >= 8 && zoom < 11) key = 4;\n    else if (zoom >= 6 && zoom < 8) key = 3;\n    else if (zoom >= 3 && zoom < 6) key = 2;\n    else if (zoom >= 1 && zoom < 3) key = 1;\n    else key = 1; // eventually we can map the whole planet at once\n\n    return key;\n};\n\n/**\n * Returns a Geohash out of a latitude and longitude that is `numberOfChars` long.\n *\n * @param {number|string} latitude\n * @param {number|string} longitude\n * @param {number} numberOfChars\n * @returns {string}\n */\nexport const encode = (\n    latitude: number | string,\n    longitude: number | string,\n    numberOfChars: number | string,\n): string => {\n    if (numberOfChars === ENCODE_AUTO) {\n        if (typeof (latitude) === 'number' || typeof (longitude) === 'number') {\n            throw new Error('string notation required for auto precision.');\n        }\n\n        const decSigFigsLat   = latitude.split('.')[1].length;\n        const decSigFigsLong  = longitude.split('.')[1].length;\n        const numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n\n        numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n    } else if (numberOfChars === undefined) {\n        numberOfChars = 9;\n    }\n\n    longitude = parseFloat(longitude);\n    latitude = parseFloat(latitude);\n    numberOfChars = parseInt(numberOfChars, 10);\n\n    const chars   = [];\n    let bits      = 0;\n    let bitsTotal = 0;\n    let hashValue = 0;\n    let maxLat    = 90;\n    let minLat    = -90;\n    let maxLon    = 180;\n    let minLon    = -180;\n    let mid;\n\n    while (chars.length < numberOfChars) {\n        if (bitsTotal % 2 === 0) {\n            mid = (maxLon + minLon) / 2;\n            if (longitude > mid) {\n                // eslint-disable-next-line no-bitwise\n                hashValue = (hashValue << 1) + 1;\n                minLon = mid;\n            } else {\n                // eslint-disable-next-line no-bitwise\n                hashValue = (hashValue << 1) + 0;\n                maxLon = mid;\n            }\n        } else {\n            mid = (maxLat + minLat) / 2;\n\n            if (latitude > mid) {\n                // eslint-disable-next-line no-bitwise\n                hashValue = (hashValue << 1) + 1;\n                minLat = mid;\n            } else {\n                // eslint-disable-next-line no-bitwise\n                hashValue = (hashValue << 1) + 0;\n                maxLat = mid;\n            }\n        }\n\n        bits += 1;\n        bitsTotal += 1;\n\n        if (bits === 5) {\n            const code = BASE32_CODES[hashValue];\n            chars.push(code);\n            bits = 0;\n            hashValue = 0;\n        }\n    }\n\n    return chars.join('');\n};\n\n/**\n * Returns a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {number} latitude\n * @param {number} longitude\n * @param {number} bitDepth\n * @returns {number}\n */\nexport const encodeInt = (latitude: number, longitude: number, bitDepth: ?number): number => {\n    bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n    let bitsTotal    = 0;\n    let maxLat       = 90;\n    let minLat       = -90;\n    let maxLon       = 180;\n    let minLon       = -180;\n    let mid;\n    let combinedBits = 0;\n\n    while (bitsTotal < bitDepth) {\n        combinedBits *= 2;\n\n        if (bitsTotal % 2 === 0) {\n            mid = (maxLon + minLon) / 2;\n            if (longitude > mid) {\n                combinedBits += 1;\n                minLon = mid;\n            } else {\n                maxLon = mid;\n            }\n        } else {\n            mid = (maxLat + minLat) / 2;\n\n            if (latitude > mid) {\n                combinedBits += 1;\n                minLat = mid;\n            } else {\n                maxLat = mid;\n            }\n        }\n\n        bitsTotal += 1;\n    }\n    return combinedBits;\n};\n\n/**\n * Returns decoded Bounding Box hashString into a bound box matches it. Data returned in\n * a four-element array: [minlat, minlon, maxlat, maxlon].\n *\n * @param {string} hashString\n * @returns {*[]}\n */\nexport const decodeBbox = (hashString: string): *[] => {\n    let isLon     = true;\n    let maxLat    = 90;\n    let minLat    = -90;\n    let maxLon    = 180;\n    let minLon    = -180;\n    let mid;\n    let hashValue = 0;\n\n    for (let i = 0, l = hashString.length; i < l; i += 1) {\n        const code = hashString[i].toLowerCase();\n\n        hashValue = BASE32_CODES_DICT[code];\n\n        for (let bits = 4; bits >= 0; bits -= 1) {\n            // eslint-disable-next-line no-bitwise\n            const bit = (hashValue >> bits) & 1;\n\n            if (isLon) {\n                mid = (maxLon + minLon) / 2;\n                if (bit === 1) {\n                    minLon = mid;\n                } else {\n                    maxLon = mid;\n                }\n            } else {\n                mid = (maxLat + minLat) / 2;\n                if (bit === 1) {\n                    minLat = mid;\n                } else {\n                    maxLat = mid;\n                }\n            }\n            isLon = !isLon;\n        }\n    }\n    return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Returns decoded Bounding Box Integer hash number into a bound box matches it. Data\n * returned in a four-element array: [minlat, minlon, maxlat, maxlon].\n *\n * @param {number} hashInt\n * @param {number} bitDepth\n * @returns {*[]}\n */\nexport const decodeBboxInt = (hashInt: number, bitDepth: ?number): *[] => {\n    bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n    let maxLat = 90;\n    let minLat = -90;\n    let maxLon = 180;\n    let minLon = -180;\n\n    let latBit = 0;\n    let lonBit = 0;\n    const step = bitDepth / 2;\n\n    for (let i = 0; i < step; i += 1) {\n        lonBit = getBit(hashInt, ((step - i) * 2) - 1);\n        latBit = getBit(hashInt, ((step - i) * 2) - 2);\n\n        if (latBit === 0) {\n            maxLat = (maxLat + minLat) / 2;\n        } else {\n            minLat = (maxLat + minLat) / 2;\n        }\n\n        if (lonBit === 0) {\n            maxLon = (maxLon + minLon) / 2;\n        } else {\n            minLon = (maxLon + minLon) / 2;\n        }\n    }\n    return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Returns decoded a hash string into pair of latitude and longitude. A javascript object\n * is returned with keys `latitude`, `longitude` and `error`.\n *\n * @param {string} hashString\n * @returns {{latitude: number, longitude: number, error: {latitude: number, longitude: number}}}\n */\nexport const decode = (hashString: string): Object => {\n    const bbox   = decodeBbox(hashString);\n    const lat    = (bbox[0] + bbox[2]) / 2;\n    const lon    = (bbox[1] + bbox[3]) / 2;\n    const latErr = bbox[2] - lat;\n    const lonErr = bbox[3] - lon;\n\n    return {\n        latitude:  lat,\n        longitude: lon,\n        error:     { latitude: latErr, longitude: lonErr },\n    };\n};\n\n/**\n * Returns decoded a hash number into pair of latitude and longitude. A javascript object\n * is returned with keys `latitude`, `longitude` and `error`.\n *\n * @param {number} hashInt\n * @param {number} bitDepth\n * @returns {{latitude: number, longitude: number, error: {latitude: number, longitude: number}}}\n */\nexport const decodeInt = (hashInt: number, bitDepth: ?number): Object => {\n    const bbox   = decodeBboxInt(hashInt, bitDepth);\n    const lat    = (bbox[0] + bbox[2]) / 2;\n    const lon    = (bbox[1] + bbox[3]) / 2;\n    const latErr = bbox[2] - lat;\n    const lonErr = bbox[3] - lon;\n\n    return {\n        latitude:  lat,\n        longitude: lon,\n        error:     { latitude: latErr, longitude: lonErr },\n    };\n};\n\n/**\n * Returns neighbor of a geohash string in certain direction. Direction is a two-element array,\n * i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n *\n * @param {string} hashString\n * @param {*[]} direction\n * @returns {string}\n */\nexport const neighbor = (hashString: string, direction: *[]): string => {\n    const lonLat      = decode(hashString);\n    const neighborLat = lonLat.latitude + (direction[0] * lonLat.error.latitude * 2);\n    const neighborLon = lonLat.longitude + (direction[1] * lonLat.error.longitude * 2);\n\n    return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Returns neighbor of a geohash integer in certain direction. Direction is a two-element array,\n * i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n *\n * @param {number} hashInt\n * @param {*[]} direction\n * @param {number} bitDepth\n * @returns {number}\n */\nexport const neighborInt = (hashInt: number, direction: *[], bitDepth: ?number): number => {\n    bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n    const lonlat      = decodeInt(hashInt, bitDepth);\n    const neighborLat = lonlat.latitude + (direction[0] * lonlat.error.latitude * 2);\n    const neighborLon = lonlat.longitude + (direction[1] * lonlat.error.longitude * 2);\n\n    return encodeInt(neighborLat, neighborLon, bitDepth);\n};\n\n/**\n * Returns all neighbors' hashstrings clockwise from north around to northwest.\n * 7 0 1\n * 6 x 2\n * 5 4 3\n *\n * @param {string} hashString\n * @returns {*[]}\n */\nexport const neighbors = (hashString: string): *[] => {\n    const hashstringLength = hashString.length;\n    const lonlat           = decode(hashString);\n    const lat              = lonlat.latitude;\n    const lon              = lonlat.longitude;\n    const latErr           = lonlat.error.latitude * 2;\n    const lonErr           = lonlat.error.longitude * 2;\n    const encodeNeighbor   = (neighborLatDir, neighborLonDir) => {\n        const neighborLat = lat + (neighborLatDir * latErr);\n        const neighborLon = lon + (neighborLonDir * lonErr);\n\n        return encode(neighborLat, neighborLon, hashstringLength);\n    };\n\n    return [\n        encodeNeighbor(1, 0),\n        encodeNeighbor(1, 1),\n        encodeNeighbor(0, 1),\n        encodeNeighbor(-1, 1),\n        encodeNeighbor(-1, 0),\n        encodeNeighbor(-1, -1),\n        encodeNeighbor(0, -1),\n        encodeNeighbor(1, -1),\n    ];\n};\n\n/**\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n *\n * @param {number} hashInt\n * @param {number} bitDepth\n * @returns {*[]}\n */\nexport const neighborsInt = (hashInt: number, bitDepth: ?number): *[] => {\n    bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n    const lonlat            = decodeInt(hashInt, bitDepth);\n    const lat               = lonlat.latitude;\n    const lon               = lonlat.longitude;\n    const latErr            = lonlat.error.latitude * 2;\n    const lonErr            = lonlat.error.longitude * 2;\n    const encodeNeighborInt = (neighborLatDir, neighborLonDir) => {\n        const neighborLat = lat + (neighborLatDir * latErr);\n        const neighborLon = lon + (neighborLonDir * lonErr);\n\n        return encodeInt(neighborLat, neighborLon, bitDepth);\n    };\n\n    return [\n        encodeNeighborInt(1, 0),\n        encodeNeighborInt(1, 1),\n        encodeNeighborInt(0, 1),\n        encodeNeighborInt(-1, 1),\n        encodeNeighborInt(-1, 0),\n        encodeNeighborInt(-1, -1),\n        encodeNeighborInt(0, -1),\n        encodeNeighborInt(1, -1),\n    ];\n};\n\n/**\n * Returns all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n *\n * @param {number} minLat\n * @param {number} minLon\n * @param {number} maxLat\n * @param {number} maxLon\n * @param {number} numberOfChars\n * @returns {*[]}\n */\nexport const bboxes = (\n    minLat: number,\n    minLon: number,\n    maxLat: number,\n    maxLon: number,\n    numberOfChars: ?number,\n): *[] => {\n    numberOfChars = numberOfChars || 9;\n\n    const hashSouthWest = encode(minLat, minLon, numberOfChars);\n    const hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n    const latLon = decode(hashSouthWest);\n\n    const perLat = latLon.error.latitude * 2;\n    const perLon = latLon.error.longitude * 2;\n\n    const boxSouthWest = decodeBbox(hashSouthWest);\n    const boxNorthEast = decodeBbox(hashNorthEast);\n\n    const latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n    const lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n    const hashList = [];\n\n    for (let lat = 0; lat <= latStep; lat += 1) {\n        for (let lon = 0; lon <= lonStep; lon += 1) {\n            hashList.push(neighbor(hashSouthWest, [lat, lon]));\n        }\n    }\n\n    return hashList;\n};\n\n/**\n * Returns all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth.\n *\n * @param {number} minLat\n * @param {number} minLon\n * @param {number} maxLat\n * @param {number} maxLon\n * @param {number} bitDepth\n * @returns {*[]}\n */\nexport const bboxesInt = (\n    minLat: number,\n    minLon: number,\n    maxLat: number,\n    maxLon: number,\n    bitDepth: ?number,\n): *[] => {\n    bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n    const hashSouthWest = encodeInt(minLat, minLon, bitDepth);\n    const hashNorthEast = encodeInt(maxLat, maxLon, bitDepth);\n\n    const latlon = decodeInt(hashSouthWest, bitDepth);\n\n    const perLat = latlon.error.latitude * 2;\n    const perLon = latlon.error.longitude * 2;\n\n    const boxSouthWest = decodeBboxInt(hashSouthWest, bitDepth);\n    const boxNorthEast = decodeBboxInt(hashNorthEast, bitDepth);\n\n    const latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n    const lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n    const hashList = [];\n\n    for (let lat = 0; lat <= latStep; lat += 1) {\n        for (let lon = 0; lon <= lonStep; lon += 1) {\n            hashList.push(neighborInt(hashSouthWest, [lat, lon], bitDepth));\n        }\n    }\n\n    return hashList;\n};\n\nexport default {\n    getBit,\n    getKeyLength,\n    encode,\n    encodeInt,\n    decodeBbox,\n    decodeBboxInt,\n    decode,\n    decodeInt,\n    neighbor,\n    neighborInt,\n    neighbors,\n    neighborsInt,\n    bboxes,\n    bboxesInt,\n};\n"],"sourceRoot":""}