{"version":3,"sources":["webpack://geohash/webpack/bootstrap","webpack://geohash/./src/geohash.js"],"names":["BASE32_CODES","BASE32_CODES_DICT","ENCODE_AUTO","i","length","charAt","SIGFIG_HASH_LENGTH","DEFAULT_BIT_DEPTH","getBit","bits","position","GeoHash","zoom","key","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","decSigFigsLong","numberOfSigFigs","Math","max","undefined","parseFloat","parseInt","chars","bitsTotal","hashValue","maxLat","minLat","maxLon","minLon","mid","code","push","join","bitDepth","combinedBits","hashString","isLon","l","toLowerCase","bit","hashInt","latBit","lonBit","step","bbox","decodeBbox","lat","lon","latErr","lonErr","error","decodeBboxInt","direction","lonLat","decode","neighborLat","neighborLon","encode","lonlat","decodeInt","encodeInt","hashstringLength","encodeNeighbor","neighborLatDir","neighborLonDir","encodeNeighborInt","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","neighbor","latlon","neighborInt"],"mappings":"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","file":"build/geohash.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/geohash.js\");\n","// @flow\n/**\n * The Geohash algorithm was first described by Gustavo Niemeyer in February 2008. By interleaving\n * latitude and longitude information in a bitwise fashion, a composite value is generated that\n * provides a high resolution geographic point, and is well suited for storage or transmission as a\n * character string.\n *\n * Geohash also has the property that as the number of digits decreases (from the right), accuracy\n * degrades. This property can be used to do bounding box searches, as points near to one another\n * will share similar Geohash prefixes.\n *\n */\nexport const BASE32_CODES      = '0123456789bcdefghjkmnpqrstuvwxyz';\nexport const BASE32_CODES_DICT = {};\nexport const ENCODE_AUTO       = 'auto';\n\nfor (let i = 0; i < BASE32_CODES.length; i += 1) {\n    BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\n/**\n * Significant Figure Hash Length.\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type {*[]}\n */\nexport const SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n\n/**\n * @type {number}\n */\nconst DEFAULT_BIT_DEPTH = 52;\n\n/**\n * Возвращает бит.\n *\n * @param {number} bits\n * @param {number} position\n * @return {number}\n */\n// eslint-disable-next-line no-bitwise\nexport const getBit = (bits: number, position: number): number => (bits / (2 ** position)) & 0x01;\n\nexport default class GeoHash {\n    /**\n     * Gets an appropriate key length for a certain zoom.\n     *\n     * @param {number} zoom\n     * @return {number}\n     */\n    static getKeyLength(zoom: number): number {\n        let key;\n\n        if (zoom >= 17) key = 8;\n        else if (zoom >= 15 && zoom < 17) key = 7;\n        else if (zoom >= 13 && zoom < 15) key = 6;\n        else if (zoom >= 11 && zoom < 13) key = 5;\n        else if (zoom >= 8 && zoom < 11) key = 4;\n        else if (zoom >= 6 && zoom < 8) key = 3;\n        else if (zoom >= 3 && zoom < 6) key = 2;\n        else if (zoom >= 1 && zoom < 3) key = 1;\n        else key = 1; // eventually we can map the whole planet at once\n\n        return key;\n    }\n\n    /**\n     * Encode\n     * Create a Geohash out of a latitude and longitude that is `numberOfChars` long.\n     *\n     * @param {number|string} latitude\n     * @param {number|string} longitude\n     * @param {number} numberOfChars\n     * @returns {string}\n     */\n    static encode(\n        latitude: number | string,\n        longitude: number | string,\n        numberOfChars: number | string,\n    ): string {\n        if (numberOfChars === ENCODE_AUTO) {\n            if (typeof (latitude) === 'number' || typeof (longitude) === 'number') {\n                throw new Error('string notation required for auto precision.');\n            }\n\n            const decSigFigsLat   = latitude.split('.')[1].length;\n            const decSigFigsLong  = longitude.split('.')[1].length;\n            const numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n\n            numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n        } else if (numberOfChars === undefined) {\n            numberOfChars = 9;\n        }\n\n        longitude = parseFloat(longitude);\n        latitude = parseFloat(latitude);\n        numberOfChars = parseInt(numberOfChars, 10);\n\n        const chars   = [];\n        let bits      = 0;\n        let bitsTotal = 0;\n        let hashValue = 0;\n        let maxLat    = 90;\n        let minLat    = -90;\n        let maxLon    = 180;\n        let minLon    = -180;\n        let mid;\n\n        while (chars.length < numberOfChars) {\n            if (bitsTotal % 2 === 0) {\n                mid = (maxLon + minLon) / 2;\n                if (longitude > mid) {\n                    // eslint-disable-next-line no-bitwise\n                    hashValue = (hashValue << 1) + 1;\n                    minLon = mid;\n                } else {\n                    // eslint-disable-next-line no-bitwise\n                    hashValue = (hashValue << 1) + 0;\n                    maxLon = mid;\n                }\n            } else {\n                mid = (maxLat + minLat) / 2;\n\n                if (latitude > mid) {\n                    // eslint-disable-next-line no-bitwise\n                    hashValue = (hashValue << 1) + 1;\n                    minLat = mid;\n                } else {\n                    // eslint-disable-next-line no-bitwise\n                    hashValue = (hashValue << 1) + 0;\n                    maxLat = mid;\n                }\n            }\n\n            bits += 1;\n            bitsTotal += 1;\n\n            if (bits === 5) {\n                const code = BASE32_CODES[hashValue];\n                chars.push(code);\n                bits = 0;\n                hashValue = 0;\n            }\n        }\n\n        return chars.join('');\n    }\n\n    /**\n     * Encode Integer.\n     * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n     *\n     * @param {number} latitude\n     * @param {number} longitude\n     * @param {number} bitDepth\n     *\n     * @returns {number}\n     */\n    static encodeInt(latitude: number, longitude: number, bitDepth: ?number): number {\n        bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n        let bitsTotal    = 0;\n        let maxLat       = 90;\n        let minLat       = -90;\n        let maxLon       = 180;\n        let minLon       = -180;\n        let mid;\n        let combinedBits = 0;\n\n        while (bitsTotal < bitDepth) {\n            combinedBits *= 2;\n\n            if (bitsTotal % 2 === 0) {\n                mid = (maxLon + minLon) / 2;\n                if (longitude > mid) {\n                    combinedBits += 1;\n                    minLon = mid;\n                } else {\n                    maxLon = mid;\n                }\n            } else {\n                mid = (maxLat + minLat) / 2;\n\n                if (latitude > mid) {\n                    combinedBits += 1;\n                    minLat = mid;\n                } else {\n                    maxLat = mid;\n                }\n            }\n\n            bitsTotal += 1;\n        }\n        return combinedBits;\n    }\n\n    /**\n     * Decode Bounding Box.\n     * Decode hashString into a bound box matches it. Data returned in a four-element array:\n     * [minlat, minlon, maxlat, maxlon]\n     *\n     * @param {string} hashString\n     * @returns {*[]}\n     */\n    static decodeBbox(hashString: string): *[] {\n        let isLon     = true;\n        let maxLat    = 90;\n        let minLat    = -90;\n        let maxLon    = 180;\n        let minLon    = -180;\n        let mid;\n        let hashValue = 0;\n\n        for (let i = 0, l = hashString.length; i < l; i += 1) {\n            const code = hashString[i].toLowerCase();\n\n            hashValue = BASE32_CODES_DICT[code];\n\n            for (let bits = 4; bits >= 0; bits -= 1) {\n                // eslint-disable-next-line no-bitwise\n                const bit = (hashValue >> bits) & 1;\n\n                if (isLon) {\n                    mid = (maxLon + minLon) / 2;\n                    if (bit === 1) {\n                        minLon = mid;\n                    } else {\n                        maxLon = mid;\n                    }\n                } else {\n                    mid = (maxLat + minLat) / 2;\n                    if (bit === 1) {\n                        minLat = mid;\n                    } else {\n                        maxLat = mid;\n                    }\n                }\n                isLon = !isLon;\n            }\n        }\n        return [minLat, minLon, maxLat, maxLon];\n    }\n\n    /**\n     * Decode Bounding Box Integer.\n     * Decode hash number into a bound box matches it. Data returned in a four-element array:\n     * [minlat, minlon, maxlat, maxlon]\n     *\n     * @param {number} hashInt\n     * @param {number} bitDepth\n     * @returns {*[]}\n     */\n    static decodeBboxInt(hashInt: number, bitDepth: ?number): *[] {\n        bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n        let maxLat = 90;\n        let minLat = -90;\n        let maxLon = 180;\n        let minLon = -180;\n\n        let latBit = 0;\n        let lonBit = 0;\n        const step = bitDepth / 2;\n\n        for (let i = 0; i < step; i += 1) {\n            lonBit = getBit(hashInt, ((step - i) * 2) - 1);\n            latBit = getBit(hashInt, ((step - i) * 2) - 2);\n\n            if (latBit === 0) {\n                maxLat = (maxLat + minLat) / 2;\n            } else {\n                minLat = (maxLat + minLat) / 2;\n            }\n\n            if (lonBit === 0) {\n                maxLon = (maxLon + minLon) / 2;\n            } else {\n                minLon = (maxLon + minLon) / 2;\n            }\n        }\n        return [minLat, minLon, maxLat, maxLon];\n    }\n\n    /**\n     * Decode.\n     * Decode a hash string into pair of latitude and longitude. A javascript object is returned\n     * with keys `latitude`, `longitude` and `error`.\n     *\n     * @param {string} hashString\n     * @returns {{latitude: number, longitude: number,\n     * error: {latitude: number, longitude: number}}}\n     */\n    static decode(hashString: string): Object {\n        const bbox   = GeoHash.decodeBbox(hashString);\n        const lat    = (bbox[0] + bbox[2]) / 2;\n        const lon    = (bbox[1] + bbox[3]) / 2;\n        const latErr = bbox[2] - lat;\n        const lonErr = bbox[3] - lon;\n\n        return {\n            latitude:  lat,\n            longitude: lon,\n            error:     { latitude: latErr, longitude: lonErr },\n        };\n    }\n\n    /**\n     * Decode Integer.\n     * Decode a hash number into pair of latitude and longitude. A javascript object is returned\n     * with keys `latitude`, `longitude` and `error`.\n     *\n     * @param {number} hashInt\n     * @param {number} bitDepth\n     * @returns {{latitude: number, longitude: number,\n     * error: {latitude: number, longitude: number}}}\n     */\n    static decodeInt(hashInt: number, bitDepth: ?number): Object {\n        const bbox   = GeoHash.decodeBboxInt(hashInt, bitDepth);\n        const lat    = (bbox[0] + bbox[2]) / 2;\n        const lon    = (bbox[1] + bbox[3]) / 2;\n        const latErr = bbox[2] - lat;\n        const lonErr = bbox[3] - lon;\n\n        return {\n            latitude:  lat,\n            longitude: lon,\n            error:     { latitude: latErr, longitude: lonErr },\n        };\n    }\n\n    /**\n     * Neighbor\n     *\n     * Find neighbor of a geohash string in certain direction. Direction is a two-element array,\n     * i.e. [1,0] means north, [-1,-1] means southwest.\n     * direction [lat, lon], i.e.\n     * [1,0] - north\n     * [1,1] - northeast\n     *\n     * @param {string} hashString\n     * @param {*[]} direction\n     *\n     * @returns {string}\n     */\n    static neighbor(hashString: string, direction: *[]): string {\n        const lonLat      = GeoHash.decode(hashString);\n        const neighborLat = lonLat.latitude + (direction[0] * lonLat.error.latitude * 2);\n        const neighborLon = lonLat.longitude + (direction[1] * lonLat.error.longitude * 2);\n\n        return GeoHash.encode(neighborLat, neighborLon, hashString.length);\n    }\n\n    /**\n     * Neighbor Integer\n     *\n     * Find neighbor of a geohash integer in certain direction. Direction is a two-element array,\n     * i.e. [1,0] means north, [-1,-1] means southwest.\n     * direction [lat, lon], i.e.\n     * [1,0] - north\n     * [1,1] - northeast\n     *\n     * @param {number} hashInt\n     * @param {*[]} direction\n     * @param {number} bitDepth\n     *\n     * @returns {number}\n     */\n    static neighborInt(hashInt: number, direction: *[], bitDepth: ?number): number {\n        bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n        const lonlat      = GeoHash.decodeInt(hashInt, bitDepth);\n        const neighborLat = lonlat.latitude + (direction[0] * lonlat.error.latitude * 2);\n        const neighborLon = lonlat.longitude + (direction[1] * lonlat.error.longitude * 2);\n\n        return GeoHash.encodeInt(neighborLat, neighborLon, bitDepth);\n    }\n\n    /**\n     * Neighbors.\n     * Returns all neighbors' hashstrings clockwise from north around to northwest\n     * 7 0 1\n     * 6 x 2\n     * 5 4 3\n     *\n     * @param {string} hashString\n     *\n     * @returns {*[]}\n     */\n    static neighbors(hashString: string): *[] {\n        const hashstringLength = hashString.length;\n        const lonlat           = GeoHash.decode(hashString);\n        const lat              = lonlat.latitude;\n        const lon              = lonlat.longitude;\n        const latErr           = lonlat.error.latitude * 2;\n        const lonErr           = lonlat.error.longitude * 2;\n        const encodeNeighbor   = (neighborLatDir, neighborLonDir) => {\n            const neighborLat = lat + (neighborLatDir * latErr);\n            const neighborLon = lon + (neighborLonDir * lonErr);\n\n            return GeoHash.encode(neighborLat, neighborLon, hashstringLength);\n        };\n\n        return [\n            encodeNeighbor(1, 0),\n            encodeNeighbor(1, 1),\n            encodeNeighbor(0, 1),\n            encodeNeighbor(-1, 1),\n            encodeNeighbor(-1, 0),\n            encodeNeighbor(-1, -1),\n            encodeNeighbor(0, -1),\n            encodeNeighbor(1, -1),\n        ];\n    }\n\n    /**\n     * Neighbors Integer.\n     * Returns all neighbors' hash integers clockwise from north around to northwest\n     * 7 0 1\n     * 6 x 2\n     * 5 4 3\n     *\n     * @param {number} hashInt\n     * @param {number} bitDepth\n     *\n     * @returns {*[]}\n     */\n    static neighborsInt(hashInt: number, bitDepth: ?number): *[] {\n        bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n        const lonlat            = GeoHash.decodeInt(hashInt, bitDepth);\n        const lat               = lonlat.latitude;\n        const lon               = lonlat.longitude;\n        const latErr            = lonlat.error.latitude * 2;\n        const lonErr            = lonlat.error.longitude * 2;\n        const encodeNeighborInt = (neighborLatDir, neighborLonDir) => {\n            const neighborLat = lat + (neighborLatDir * latErr);\n            const neighborLon = lon + (neighborLonDir * lonErr);\n\n            return GeoHash.encodeInt(neighborLat, neighborLon, bitDepth);\n        };\n\n        return [\n            encodeNeighborInt(1, 0),\n            encodeNeighborInt(1, 1),\n            encodeNeighborInt(0, 1),\n            encodeNeighborInt(-1, 1),\n            encodeNeighborInt(-1, 0),\n            encodeNeighborInt(-1, -1),\n            encodeNeighborInt(0, -1),\n            encodeNeighborInt(1, -1),\n        ];\n    }\n\n    /**\n     * Bounding Boxes\n     * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n     *\n     * @param {number} minLat\n     * @param {number} minLon\n     * @param {number} maxLat\n     * @param {number} maxLon\n     * @param {number} numberOfChars\n     *\n     * @returns {*[]}\n     */\n    static bboxes(\n        minLat: number,\n        minLon: number,\n        maxLat: number,\n        maxLon: number,\n        numberOfChars: ?number,\n    ): *[] {\n        numberOfChars = numberOfChars || 9;\n\n        const hashSouthWest = GeoHash.encode(minLat, minLon, numberOfChars);\n        const hashNorthEast = GeoHash.encode(maxLat, maxLon, numberOfChars);\n\n        const latLon = GeoHash.decode(hashSouthWest);\n\n        const perLat = latLon.error.latitude * 2;\n        const perLon = latLon.error.longitude * 2;\n\n        const boxSouthWest = GeoHash.decodeBbox(hashSouthWest);\n        const boxNorthEast = GeoHash.decodeBbox(hashNorthEast);\n\n        const latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n        const lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n        const hashList = [];\n\n        for (let lat = 0; lat <= latStep; lat += 1) {\n            for (let lon = 0; lon <= lonStep; lon += 1) {\n                hashList.push(GeoHash.neighbor(hashSouthWest, [lat, lon]));\n            }\n        }\n\n        return hashList;\n    }\n\n    /**\n     * Bounding Boxes Integer\n     * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth.\n     *\n     * @param {number} minLat\n     * @param {number} minLon\n     * @param {number} maxLat\n     * @param {number} maxLon\n     * @param {number} bitDepth\n     *\n     * @returns {*[]}\n     */\n    static bboxesInt(\n        minLat: number,\n        minLon: number,\n        maxLat: number,\n        maxLon: number,\n        bitDepth: ?number,\n    ): *[] {\n        bitDepth = bitDepth || DEFAULT_BIT_DEPTH;\n\n        const hashSouthWest = GeoHash.encodeInt(minLat, minLon, bitDepth);\n        const hashNorthEast = GeoHash.encodeInt(maxLat, maxLon, bitDepth);\n\n        const latlon = GeoHash.decodeInt(hashSouthWest, bitDepth);\n\n        const perLat = latlon.error.latitude * 2;\n        const perLon = latlon.error.longitude * 2;\n\n        const boxSouthWest = GeoHash.decodeBboxInt(hashSouthWest, bitDepth);\n        const boxNorthEast = GeoHash.decodeBboxInt(hashNorthEast, bitDepth);\n\n        const latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n        const lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n        const hashList = [];\n\n        for (let lat = 0; lat <= latStep; lat += 1) {\n            for (let lon = 0; lon <= lonStep; lon += 1) {\n                hashList.push(GeoHash.neighborInt(hashSouthWest, [lat, lon], bitDepth));\n            }\n        }\n\n        return hashList;\n    }\n}\n"],"sourceRoot":""}